/*****************************************************************
 * Source file : apppager.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 05/11/2008 16:39
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#include <idl4glue.h>
#include <l4/types.h>
#include <if/iffilesystem.h>
#include <l4io.h>
#include <elf.h>

#include "apppager.h"
#include "apppager-server.h"

extern L4_ThreadId_t locatorid;
extern L4_ThreadId_t fsysid;


/* Interface apppager */

IDL4_INLINE void apppager_pagefault_implementation(CORBA_Object _caller, const L4_Word_t address, const L4_Word_t ip, const L4_Word_t privileges, idl4_fpage_t *return_page, idl4_server_environment *_env)

{
  // implementation of IF_PAGEFAULT::pagefault
  
  // determine corresponding thread, space and file slot
  Thread * t = Thread::find(static_cast<L4_ThreadId_t>(_caller));
  Space * s = t->space;
  L4_Fpage_t fs = s->getFileSlot();

  // load ELF header
  Elf32_Ehdr * hdr = reinterpret_cast<Elf32_Ehdr *>(L4_Address(fs));

  L4_Word_t page_start = address & 0xfffff000UL;
  L4_Word_t page_end   = address | 0x00000fffUL;

  // reserve and zero free page
  Page * apage = Page::alloc();

  if (apage == NULL) 
      panic("[APPPAGER] Out Of Memory in pagefault handling\n");
  s->addPage(apage);

  L4_Fpage_t page = apage->getDesc();

  memset((void *)L4_Address(page), 0, L4_Size(page));

  // find and copy relevant ELF sections
  Elf32_Phdr * phdr = (Elf32_Phdr *)(hdr->e_phoff + (L4_Word_t)hdr);

  for(int i = 0; i < hdr->e_phnum; i++){

      if(phdr[i].p_type == PT_LOAD){

          // Do page and program section overlap?
          if((page_end >= phdr[i].p_vaddr) // Page ends after section start
                  && (phdr[i].p_vaddr + phdr[i].p_memsz > page_start)){ // and vice versa

            // compute copy source start
            L4_Word_t s_offset = 0;
            if (phdr[i].p_vaddr < page_start) {
              s_offset  = page_start - phdr[i].p_vaddr; // Aligned offset of page
            }

            // compute copy destination start
            L4_Word_t d_offset = 0;
            if (phdr[i].p_vaddr > page_start) {
              d_offset = phdr[i].p_vaddr - page_start;
            }

            // determine amount to copy
            L4_Word_t s_max = phdr[i].p_filesz - s_offset;
            L4_Word_t d_max = 0x1000UL - d_offset;
            L4_Word_t copylength = (s_max > d_max) ? d_max : s_max;

            // add respective base addresses
            s_offset += (L4_Word_t)hdr + phdr[i].p_offset;
            d_offset += L4_Address(page);

            // Copy from image to page
            memcpy((void *)d_offset, (void *)s_offset, copylength);
            
          }
      }
  }

  // Set return page
  idl4_fpage_set_mode(return_page, IDL4_MODE_MAP);
  idl4_fpage_set_page(return_page, page);
  idl4_fpage_set_base(return_page, page_end);
  idl4_fpage_set_permissions(return_page, IDL4_PERM_FULL);
  return;
}

IDL4_PUBLISH_APPPAGER_PAGEFAULT(apppager_pagefault_implementation);

IDL4_INLINE void apppager_associateImage_implementation(CORBA_Object _caller, const L4_ThreadId_t *thread, const CORBA_char *filename, L4_Word_t *initialIp, idl4_server_environment *_env)

{
  /* implementation of IF_APPPAGER::associateImage */
  Elf32_Ehdr * hdr = NULL;
  CORBA_Environment env(idl4_default_environment);
  idl4_fpage_t fpage;
  
  // create data structures
  Thread * t = new Thread(*thread);
  Space * s = t->space;

  // request corresponding "file" from file server
  env._rcv_window = L4_MapGrantItems(s->getFileSlot());
  IF_FILESYSTEM_mapFile((CORBA_Object) fsysid, filename, &fpage, &env);

  // read ELF header
  hdr = reinterpret_cast<Elf32_Ehdr*>(L4_Address(s->getFileSlot()));
  *initialIp = hdr->e_entry;

  // Send startup IPC
  L4_Msg_t msg;
  L4_Clear(&msg);
  L4_Append(&msg, static_cast<L4_Word_t>(hdr->e_entry));
  L4_Append(&msg, 0);
  L4_Load(&msg);
  L4_Send(*thread);
  
  return;
}

IDL4_PUBLISH_APPPAGER_ASSOCIATEIMAGE(apppager_associateImage_implementation);

IDL4_INLINE void apppager_copyAssociation_implementation(CORBA_Object _caller, const L4_ThreadId_t *fromThread, const L4_ThreadId_t *toThread, idl4_server_environment *_env)

{
  /* implementation of IF_APPPAGER::copyAssociation */
  // create data structures
  Thread * t;
  t = new Thread(*toThread, Thread::find(*fromThread)->space);
  // everything else should settle magically...
  
  return;
}

IDL4_PUBLISH_APPPAGER_COPYASSOCIATION(apppager_copyAssociation_implementation);

IDL4_INLINE void apppager_deleteAssociation_implementation(CORBA_Object _caller, const L4_ThreadId_t *thread, idl4_server_environment *_env)

{
  /* implementation of IF_APPPAGER::deleteAssociation */
  Thread * t = Thread::find(*thread);
  delete t;
  
  return;
}

IDL4_PUBLISH_APPPAGER_DELETEASSOCIATION(apppager_deleteAssociation_implementation);

IDL4_INLINE L4_ThreadId_t apppager_getLocator_implementation(CORBA_Object _caller, idl4_server_environment *_env)

{
  /* implementation of IF_APPPAGER::getLocator */
  
  return locatorid;
}

IDL4_PUBLISH_APPPAGER_GETLOCATOR(apppager_getLocator_implementation);

void *apppager_vtable_12[APPPAGER_DEFAULT_VTABLE_SIZE] = APPPAGER_DEFAULT_VTABLE_12;
void *apppager_vtable_discard[APPPAGER_DEFAULT_VTABLE_SIZE] = APPPAGER_DEFAULT_VTABLE_DISCARD;
void **apppager_itable[16] = { apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_12, apppager_vtable_discard, apppager_vtable_discard, apppager_vtable_discard };
void *apppager_ktable[APPPAGER_DEFAULT_KTABLE_SIZE] = APPPAGER_DEFAULT_KTABLE;

void apppager_server()

{
  L4_ThreadId_t partner;
  L4_MsgTag_t msgtag;
  idl4_msgbuf_t msgbuf;
  long cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < APPPAGER_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          if (IDL4_EXPECT_FALSE(idl4_is_kernel_message(msgtag)))
            idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, apppager_ktable[idl4_get_kernel_message_id(msgtag) & APPPAGER_KID_MASK]);
            else idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, apppager_itable[idl4_get_interface_id(&msgtag) & APPPAGER_IID_MASK][idl4_get_function_id(&msgtag) & APPPAGER_FID_MASK]);
        }
    }
}

void apppager_discard()

{
}

