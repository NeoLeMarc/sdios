/*****************************************************************
 * Source file : syscall.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 26/06/2008 13:48
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#include <idl4glue.h>
#include <l4io.h>
#include "syscall-server.h"

/* Interface syscall */

IDL4_INLINE void syscall_ThreadControl_implementation(CORBA_Object _caller, const L4_ThreadId_t *dest, const L4_ThreadId_t *SpaceSpecifier, const L4_ThreadId_t *scheduler, const L4_ThreadId_t *pager, const L4_Word_t UtcbLocation, idl4_server_environment *_env)

{
  /* implementation of IF_SYSCALL::ThreadControl */

  L4_Word_t result = L4_ThreadControl(*dest, *SpaceSpecifier, *scheduler, *pager, (void *)UtcbLocation);
  if (result == 0) {
    switch (L4_ErrorCode()) {
      case L4_ErrNoPrivilege:
        printf("[SYSCALL] ThreadControl failed due to insufficient privileges.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_noPrivilege, 0);
        break;
      case L4_ErrInvalidThread:
        printf("[SYSCALL] ThreadControl failed due to an invalid thread to be changed.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_invalidThread, 0);
        break;
      case L4_ErrInvalidSpace:
        printf("[SYSCALL] ThreadControl failed due to an invalid AS mate thread.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_invalidSpace, 0);
        break;
      case L4_ErrInvalidScheduler:
        printf("[SYSCALL] ThreadControl failed due to an invalid scheduler thread.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_invalidScheduler, 0);
        break;
      case L4_ErrUtcbArea:
        printf("[SYSCALL] ThreadControl failed due to an invalid UTCB location.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_invalidUtcbLocation, 0);
        break;
      case L4_ErrNoMem:
        printf("[SYSCALL] ThreadControl failed due to insufficient memory.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_outOfMemory, 0);
        break;
      default:
        printf("[SYSCALL] ThreadControl failed due to an unknown error.\n");
        panic("L4 API violation. Guru meditation.");
    }
  }
  
  return;
}

IDL4_PUBLISH_SYSCALL_THREADCONTROL(syscall_ThreadControl_implementation);

IDL4_INLINE void syscall_SpaceControl_implementation(CORBA_Object _caller, const L4_ThreadId_t *SpaceSpecifier, const L4_Word_t control, const L4_Fpage_t *KernelInterfacePageArea, const L4_Fpage_t *UtcbArea, const L4_ThreadId_t *Redirector, L4_Word_t *old_Control, idl4_server_environment *_env)

{
  /* implementation of IF_SYSCALL::SpaceControl */

  L4_Word_t result = L4_SpaceControl(*SpaceSpecifier, control, *KernelInterfacePageArea, *UtcbArea, *Redirector, old_Control);
  if (result == 0) {
    switch (L4_ErrorCode()) {
      case L4_ErrNoPrivilege:
        printf("[SYSCALL] SpaceControl failed due to insufficient privileges.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_noPrivilege, 0);
        break;
      case L4_ErrInvalidSpace:
        printf("[SYSCALL] SpaceControl failed due to an invalid AS mate thread.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_invalidSpace, 0);
        break;
      case L4_ErrUtcbArea:
        printf("[SYSCALL] SpaceControl failed due to an invalid UTCB area definition.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_invalidUtcbLocation, 0);
        break;
      case L4_ErrKipArea:
        printf("[SYSCALL] SpaceControl failed due to an invalid KIP area definition.\n");
        CORBA_exception_set(_env, ex_IF_SYSCALL_invalidKipArea, 0);
        break;
      default:
        printf("[SYSCALL] SpaceControl failed due to an unknown error.\n");
        panic("L4 API violation. Guru meditation.");
    }
  }
 
  
  return;
}

IDL4_PUBLISH_SYSCALL_SPACECONTROL(syscall_SpaceControl_implementation);

void *syscall_vtable_3[SYSCALL_DEFAULT_VTABLE_SIZE] = SYSCALL_DEFAULT_VTABLE_3;
void *syscall_vtable_discard[SYSCALL_DEFAULT_VTABLE_SIZE] = SYSCALL_DEFAULT_VTABLE_DISCARD;
void **syscall_itable[4] = { syscall_vtable_discard, syscall_vtable_discard, syscall_vtable_discard, syscall_vtable_3 };

void syscall_server(void)

{
  L4_ThreadId_t partner;
  L4_MsgTag_t msgtag;
  idl4_msgbuf_t msgbuf;
  long cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < SYSCALL_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, syscall_itable[idl4_get_interface_id(&msgtag) & SYSCALL_IID_MASK][idl4_get_function_id(&msgtag) & SYSCALL_FID_MASK]);
        }
    }
}

void syscall_discard(void)

{
}

